
Algorithm Problem with Python — 13day

***


### **문제 설명 📖**

점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.

전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.

**제한사항**

- 전체 학생의 수는 2명 이상 30명 이하입니다.
- 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
- 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
- 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
- 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.

**입출력 예**

![](https://images.velog.io/images/qmasem/post/dd5c5173-573c-431b-9033-fc00eb0aa7ee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-02-24%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2010.11.54.png)

예제 #1
1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.

예제 #2
3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.

***

### **문제 이해 🔑**

주어진 두 배열을 비교하는 문제입니다.
lost 배열의 각 원소의 +1 or -1 값이 존재하는지 확인하면 됩니다.
존재하는 값이 있다면 lost배열을 지워나가며 최종적으로 남은 lost의 길이와 전체 학생수로 주어진 n의 길이의 차를 구합니다.
경우의 수로는 여분의 체육을 갖고 있는 친구가 잃어버린 경우가 있고, +1 or -1인 이유인 체격에 맞게 빌려하는 경우가 있습니다.
또한 여분은 여러 벌이 아니라 1벌인 점을 감안하여 문제를 풀었습니다.


***

### **수도 코드 ✍️**

1. lost와 reserve배열을 set() 함수를 통해 집합으로 만들어 집합 연산을 가능하게 만듭니다.
2. 1에서 만든 set_lost와 set_reserve를 차집합을 통해 여분이 있는 친구가 잃어버린 경우를 제외시킵니다.
3. 반복문을 통해 체육복을 잃어버린 친구 앞, 뒤 번호를 찾아 빌릴 수 있는 경우 set_lost에서 제거합니다.
4. 모든 반복문이 끝나면 전체 학생 수 에서 체육복이 없는 친구의 수를 빼고 리턴합니다.

***

### 정리 😄

set() 함수를 통해 집합을 만들 수 있고, 집합 연산을 할 수 있다는 점이 문제의 키가 되었습니다.
여분이 있는 친구가 잃어버렸다는 경우의 수를 제거하니 그 이후는 간단하게 풀 수 있었습니다.
두 배열을 비교할 때 중복된 값을 제거하는 경우 반복문과 remove를 통해 길어질 수 있는 코드는 set() 함수를 이용하면 좋다는 점을 알게 되었습니다.




