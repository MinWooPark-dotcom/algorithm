
Algorithm Problem with Python — 19day
코드스테이츠에 저작권이 있는 알고리즘 문제이기에 자세한 내용은 적지 않겠습니다.
***


### **문제 설명 📖**
가위바위보에서 낼 수 있는 모든 경우의 수를 구하는 문제입니다.


**제한사항**

- 

**입출력 예**
입력
- 없음

출력
- 2차원 배열(arr[i])을 리턴해야 합니다.




***
### **문제 이해 🔑**

경우의 수를 구하는 문제입니다.
첫 번째 판의 경우의 수는 가위, 바위, 보로 총 3개 입니다.
두 번째 판이 있는 경우 첫 번째 판 가위에서 또 3개의 경우의 수가 파생됩니다.
가위-가위, 가위-바위, 가위-보로 파생됩니다.
나머지 바위와 보도 마찬가지입니다.
그렇게 1판 - 3개의 경우의 수, 2판 - 9개의 경우의 수... 
1판이 올라갈 때 마다 3의 제곱이 됩니다.
이 모든 경우의 수를 ['가위','가위','가위'], ['가위','가위','보'] ... 이런 식으로 배열로 만들어야 합니다.
n번 째 판에서 n+1판이 존재한다면 다음 원소를 반복문을 통해 가위,바위,보 모두 순회하여 경우의 수를 만들어야 합니다.
예를 들어, 2판을 진행한다면 1판에서 가위를 내면 2판에서 가위-가위, 가위-바위, 가위-보 라는 경우의 수를 만들어야 합니다.
가위의 경우의 수를 다 만들었다면 바위의 경우의 수를 똑같이 진행합니다.
이 로직은 반복문과 재귀함수를 통해 작성할 수 있습니다.

***

### **수도 코드 ✍️**

1. 가위,바위,보를 반복문을 통해 순회합니다.
2. 각 경우의 수를 하나의 배열로 만들고 가위, 바위, 보를 차례대로 한 개씩 넣습니다. 배열에 하나를 넣을 때 마다 게임 한 판이 진행된 것이니 라운드 수를 뺍니다. 반복문과 재귀함수를 이용합니다.
3. 라운드 수가 0이 될 때까지 2를 반복하며 0이 된 경우, 다시 스택에 쌓인 순서로 돌아가 2번과 같은 로직을 실행합니다.
4. 모든 반복문이 끝나면 2차원 배열을 리턴합니다.

***


### **코드 작성 ⌨️**

생략 

``` javascript


```

***

### 정리 😄

따로 정리를 하고 공부를 했으나 블로깅을 통해 기록을 하고 싶었습니다.
그러나 자세한 내용을 적지 못해 설명이 부족해 블로깅 하기에 어려움을 느낍니다..
이번 문제를 풀면서 정리하고 싶었던 것은 결국 경우의 수를 구하는 문제였고 이런 유형에 문제는 재귀함수와 반복문을 사용하면 효율적으로 풀 수 있다는 것을 배웠다는 것입니다.